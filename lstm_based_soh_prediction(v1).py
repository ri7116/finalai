# -*- coding: utf-8 -*-
"""LSTM_Based_SOH_Prediction_v0.1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s-XW6ob8kjC0x1QCI_GRTsLLdDWc2rqv
"""
# MAGIC %md
# MAGIC ## 01. Import Library

import datetime
import numpy as np
import pandas as pd
from scipy.io import loadmat
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from sklearn import metrics
import matplotlib.pyplot as plt
import seaborn as sns
import sys
import json
# MAGIC %md
# MAGIC ## 02. Make Dictionary

def load_data(matlab_data):
  mat = loadmat(matlab_data)

  # '__'로 시작하지 않는 키를 찾아서 사용
  filename = [key for key in mat.keys() if not key.startswith('_')][0]

  print('Total data in dataset: ', len(mat[filename][0, 0]['cycle'][0]))
  counter = 0
  dataset = []
  capacity_data = []

  for i in range(len(mat[filename][0, 0]['cycle'][0])):
    row = mat[filename][0, 0]['cycle'][0, i]
    if row['type'][0] == 'discharge':
      ambient_temperature = row['ambient_temperature'][0][0]
      date_time = datetime.datetime(int(row['time'][0][0]),
                               int(row['time'][0][1]),
                               int(row['time'][0][2]),
                               int(row['time'][0][3]),
                               int(row['time'][0][4])) + datetime.timedelta(seconds=int(row['time'][0][5]))
      data = row['data']
      capacity = data[0][0]['Capacity'][0][0]
      for j in range(len(data[0][0]['Voltage_measured'][0])):
        voltage_measured = data[0][0]['Voltage_measured'][0][j]
        current_measured = data[0][0]['Current_measured'][0][j]
        temperature_measured = data[0][0]['Temperature_measured'][0][j]
        current_load = data[0][0]['Current_load'][0][j]
        voltage_load = data[0][0]['Voltage_load'][0][j]
        time = data[0][0]['Time'][0][j]
        dataset.append([counter + 1, ambient_temperature, date_time, capacity,
                        voltage_measured, current_measured,
                        temperature_measured, current_load,
                        voltage_load, time])
      capacity_data.append([counter + 1, ambient_temperature, date_time, capacity])
      counter = counter + 1

  print(dataset[0])
  return [pd.DataFrame(data=dataset,
                       columns=['cycle', 'ambient_temperature', 'date_time',
                                'capacity', 'voltage_measured', 'current_measured', 'temperature_measured',
                                'current_load', 'voltage_load', 'time']),
          pd.DataFrame(data=capacity_data,
                       columns=['cycle', 'ambient_temperature', 'date_time', 'capacity'])]

dataset, capacity = load_data("battery_soh_prediction\B0005.mat") #경로 설정 주의!!!
pd.set_option('display.max_columns', 10)


##시작지점 
print(dataset.head())
dataset.describe()

plot_df = capacity.loc[(capacity['cycle']>=1),['cycle','capacity']]
sns.set_style("whitegrid")
#deep, muted, pastel, bright, dark, colorblind
sns.set_palette('bright')
plt.figure(figsize=(12, 8))
plt.plot(plot_df['cycle'], plot_df['capacity'])
#Draw threshold
plt.plot([0.,len(capacity)], [1.4, 1.4])
plt.ylabel('Capacity')
# make x-axis ticks legible
adf = plt.gca().get_xaxis().get_major_formatter()
plt.xlabel('cycle')
plt.title('file=B0005 | type=discharge')

attrib=['cycle', 'date_time', 'capacity']
dis_ele = capacity[attrib]
C = dis_ele['capacity'][0]
for i in range(len(dis_ele)):
    dis_ele['SOH']=(dis_ele['capacity'])/C
print(dis_ele.head(5))

dis_ele.describe()

plot_df = dis_ele.loc[(dis_ele['cycle']>=1),['cycle','SOH']]
sns.set_style("whitegrid")
#deep, muted, pastel, bright, dark, colorblind
sns.set_palette('bright')
plt.figure(figsize=(12, 8))
plt.plot(plot_df['cycle'], plot_df['SOH'])
#Draw threshold
plt.plot([0.,len(capacity)], [0.70, 0.70])
plt.ylabel('SOH')
# make x-axis ticks legible
adf = plt.gca().get_xaxis().get_major_formatter()
plt.xlabel('cycle')
plt.title('file=B0005 | type=discharge')

C = dataset['capacity'][0]
soh = []
for i in range(len(dataset)):
  soh.append([dataset['capacity'][i] / C])
soh = pd.DataFrame(data=soh, columns=['SOH'])

attribs=['capacity', 'voltage_measured', 'current_measured',
         'temperature_measured', 'current_load', 'voltage_load', 'time']
train_dataset = dataset[attribs]
sc = MinMaxScaler(feature_range=(0,1))
train_dataset = sc.fit_transform(train_dataset)
print(train_dataset.shape)
print(soh.shape)

# MAGIC %md
# MAGIC ADAM optimizer

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.layers import Dropout
from tensorflow.keras.layers import Flatten
from tensorflow.keras.layers import LSTM
from tensorflow.keras.optimizers import Adam

# MAGIC %md
# MAGIC ## LSTM-Based Modeling

lstm_model = Sequential()
lstm_model.add(Dense(8, activation='relu', input_dim=train_dataset.shape[1]))
lstm_model.add(Dense(8, activation='relu'))
lstm_model.add(Dense(8, activation='relu'))
lstm_model.add(Dropout(rate=0.25))
lstm_model.add(Dense(1))
lstm_model.summary()
lstm_model.compile(optimizer=Adam(beta_1=0.9, beta_2=0.999, epsilon=1e-08), loss='mean_absolute_error')

# MAGIC %md
# MAGIC Train Model

lstm_model.fit(x=train_dataset, y=soh.to_numpy(), batch_size=25, epochs=50)

# MAGIC %md
# MAGIC ## Test Model SoH Prediction
# MAGIC B0006
dataset_val, capacity_val = load_data('battery_soh_prediction\B0006.mat') #경로 설정 주의!!
attrib=['cycle', 'date_time', 'capacity']
dis_ele = capacity_val[attrib]
C = dis_ele['capacity'][0]
for i in range(len(dis_ele)):
    dis_ele['SOH']=(dis_ele['capacity']) / C
print(dataset_val.head(5))
print(dis_ele.head(5))


#LSTM 모델
attrib=['capacity', 'voltage_measured', 'current_measured',
        'temperature_measured', 'current_load', 'voltage_load', 'time']
soh_pred = lstm_model.predict(sc.fit_transform(dataset_val[attrib]))
print(soh_pred.shape)

C = dataset_val['capacity'][0]
soh = []
for i in range(len(dataset_val)):
  soh.append(dataset_val['capacity'][i] / C)
new_soh1 = dataset_val.loc[(dataset_val['cycle'] >= 1), ['cycle']]
new_soh1['SOH'] =  soh
new_soh1['NewSOH'] = soh_pred
new_soh1 = new_soh1.groupby(['cycle']).mean().reset_index()
print(new_soh1.head(10))
rms = np.sqrt(mean_squared_error(new_soh1['SOH'], new_soh1['NewSOH']))
print('Root Mean Square Error: ', rms)

#LSTM 예측
plot_df1 = new_soh1.loc[(new_soh1['cycle']>=1),['cycle','SOH', 'NewSOH']]
sns.set_style("white")
plt.figure(figsize=(16, 10))
plt.plot(plot_df1['cycle'], plot_df1['SOH'], label='SOH')
plt.plot(plot_df1['cycle'], plot_df1['NewSOH'], label='LSTM_Predicted SOH')

#Draw threshold
plt.plot([0.,len(capacity)], [0.70, 0.70], label='Threshold')
plt.ylabel('SOH')
# make x-axis ticks legible
adf = plt.gca().get_xaxis().get_major_formatter()
plt.xlabel('cycle')
plt.legend()
plt.title('Discharge B0006')

plt.show()

dataset_val, capacity_val = load_data('battery_soh_prediction\B0005.mat') #경로 설정 주의!!
attrib=['cycle', 'date_time', 'capacity']
dis_ele = capacity_val[attrib]
rows=['cycle','capacity']
dataset=dis_ele[rows]
data_train=dataset[(dataset['cycle']<50)]
data_set_train=data_train.iloc[:,1:2].values
data_test=dataset[(dataset['cycle']>=50)]
data_set_test=data_test.iloc[:,1:2].values

sc=MinMaxScaler(feature_range=(0,1))
data_set_train=sc.fit_transform(data_set_train)
data_set_test=sc.transform(data_set_test)

X_train=[]
y_train=[]
#take the last 10t to predict 10t+1
for i in range(10,49):
    X_train.append(data_set_train[i-10:i,0])
    y_train.append(data_set_train[i,0])
X_train,y_train=np.array(X_train),np.array(y_train)

X_train=np.reshape(X_train,(X_train.shape[0],X_train.shape[1],1))

regress1 = Sequential()
regress1.add(LSTM(units=200, return_sequences=True, input_shape=(X_train.shape[1],1)))
regress1.add(Dropout(0.3))
regress1.add(LSTM(units=200, return_sequences=True))
regress1.add(Dropout(0.3))
regress1.add(LSTM(units=200, return_sequences=True))
regress1.add(Dropout(0.3))
regress1.add(LSTM(units=200))
regress1.add(Dropout(0.3))
regress1.add(Dense(units=1))
regress1.compile(optimizer='adam',loss='mean_squared_error')
regress1.summary()

regress1.fit(X_train,y_train,epochs=200,batch_size=25)

print(len(data_test))
data_total=pd.concat((data_train['capacity'], data_test['capacity']),axis=0)
inputs=data_total[len(data_total)-len(data_test)-10:].values
inputs=inputs.reshape(-1,1)
inputs=sc.transform(inputs)

#LSTM인 경우
X_test=[]
for i in range(10,129):
    X_test.append(inputs[i-10:i,0])
X_test=np.array(X_test)
X_test=np.reshape(X_test,(X_test.shape[0],X_test.shape[1],1))
pred1=regress1.predict(X_test)
print(pred1.shape)
pred1=sc.inverse_transform(pred1)
pred1=pred1[:,0]
tests=data_test.iloc[:,1:2]
rmse = np.sqrt(mean_squared_error(tests, pred1))
print('Test RMSE: %.3f' % rmse)
metrics.r2_score(tests,pred1)

ln = len(data_train)
data_test['pre']=pred1
plot_df = dataset.loc[(dataset['cycle']>=1),['cycle','capacity']] #실제 데이터

plot_per = data_test.loc[(data_test['cycle']>=ln),['cycle','pre']]
plt.figure(figsize=(16, 10))
plt.plot(plot_df['cycle'], plot_df['capacity'], label="Actual data", color='blue') #실제 데이터

plt.plot(plot_per['cycle'],plot_per['pre'],label="LSTM_Prediction data", color='red') #LSTM모델인 경우

#Draw threshold
plt.plot([0.,168], [1.38, 1.38],dashes=[6, 2], label="treshold")
plt.ylabel('Capacity')
# make x-axis ticks legible
adf = plt.gca().get_xaxis().get_major_formatter()
plt.xlabel('cycle')
plt.legend()
plt.title('file=B0005 | type=discharge -RULe=-8, window-size=10')

#특정 임계값을 기준으로 배터리의 성능 저하를 예측.
#실제 성능과 예측된 성능을 비교하여 배터리가 기준 임계점 이하로 떨어지는 사이클 시점을 각각 찾고 그 차이를 통해 잔존 수명 예측 오류(RUL error)를 계산하는 코드
pred=0
Afil=0
Pfil=0
a=data_test['capacity'].values # 실제 배터리 용량 값을 배열로 가져옴
b=data_test['pre'].values # 예측된 배터리 용량 값을 배열로 가져옴
j=0 #실제 값에서 임계점 이하인 사이클의 번호
k=0 #예측 값에서 임계점 이하인 사이클의 번
for i in range(len(a)):
    actual=a[i]

    if actual<=1.38: #임계값 1.38로 설정
        j=i
        Afil=j
        break
for i in range(len(a)):
    pred=b[i]
    if pred< 1.38:
        k=i
        Pfil=k
        break
print("Actual Fail at Cycle Number: "+ str(Afil+ln))
print("Prediction Fail at Cycle Number: "+ str(Pfil+ln))
RULerror=Pfil-Afil
print("Error of RUL= "+ str(RULerror)+ " Cycles")